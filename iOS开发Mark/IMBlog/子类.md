# 子类

## 何时使用子类

首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的 UITableViewCell ，那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不光代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。
假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个 OBJDevice 类，让一些子类如 OBJIPhoneDevice 和 OBJIPadDevice ，甚至更深层的子类如 OBJIPhone5Device 来继承，并让这些子类重写特定的方法。例如，你的 OBJDevice 类可能包含了函数 applyRoundedCornersToView:withRadius ，它有一个默认的实现，但是也能被特定的子类重写。
另一个子类化可能很有用的场景是模型对象（model object）。绝大多数情况下，我的模型对象继承自一个实现了 isEqual: 、 hash 、 copyWithZone: 和 description 等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找一个这样的基类，可以考虑使用 Mantle ，它就是这么做的，并且做得更多。）

例如自定义 View 控件, 我们可以继承自系统的 View 或者  Cell 等等在进行一层自己业务的封装, 这样不仅很好的能让其他类进行复用, 而且也能公用到系统类的很多现有方法。
还有例如


##何时不使用子类

在以往工作过的很多工程中，我见到过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。^2
幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代方案可选。在下面的章节中，我们会逐个进行更详细地描述。如果你的子类只是使用相同的接口，协议会是个非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象（configuration object）来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。


## 替代方案

###替代方案：协议（Protocols）

有时候我们为了让某个类能公用一个父类的, 1 2 个方法, 选择让其去继承自此类, 但是发现父类里面很多方法, 以及一些属性等等都没有用到, 这种情况明显不需要使用继承来实现, 我们可以使用协议的方式, 将公共的接口公开出来即可。
让每个类都是各自实现自己的方法, 不必继承自其它类, 不过这种方式需要各个类还需要重新进行一遍实现。
适合实现不是过于复杂的方法。

###替代方案：代理（Delegation）

有时候我们在继承父类方法来公用某个方法时, 可能会遇到一个问题, 就是在执行某些公用方法时, 可能还需要做一些相应的函数实现等等, 这个时候我们一般使用 子类重写父类方法, 然后在 super 实现的下面在继续去执行我们自己的函数。

这种时候比较适合使用 delegate 来进行实现,  我们通过父类配置一个 delegate, 然后让其他类来遵守, 当父类调用此方式时, 我们在 delegate 继续实现即可完成。

###替代方案：类别（Categories）

例如我们需要为系统或者别人开源的类, 添加方法或者属性的时候, 我们未必需要继承自这个类,  我们可以通过 类别的方式来进行实现, 通过 runtime 添加属性, 
以及添加相应的 实例方法和类方法等等。
添加方法时, 记得加上 前缀, 避免未来覆盖掉本类的某些方法等等。导致调试困难。


###替代方案：配置对象（Configuration Objects）

我们在 项目中可能由某个类, 实现了一套公共的方法, 例如一套主题背景, 里面包括 背景色 字体 风格等等的属性, 这些属性我们声明在父类里面。  然后在不同页面使用这套类的时候,  我们可能会声明多个不同的子类来实现。 这种情况下非常适合使用配置模式。
我们只需要在父类里面公开声明出来一个 配置对象,配置对象里面包括这些不同的属性, 然后我们每次想要使用不同的风格时 只需要传一个配置对象进来即可 。

###替代方案：组合

组合是一个非常强大的功能。
例如我们在想要自定义一个 缓存类的时候, 我们可能继承自 字典, 因为字典已经实现了一套缓存和删除的方法, 

但是这么做有几个弊端。它本来是应该被详细实现的，但只是通过字典来实现。现在，在任何需要一个 NSDictionary 参数的时候，你可以直接提供一个 OBJCache 值。但如果你想把它转为其它完全不同的东西（例如你自己的库），你就可能需要重构很多代码了。

更好的方式是，将这个字典存在一个私有属性（或者实例变量）中，对外仅仅暴露这两个 cache 方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。






## 参考

[子类](https://objccn.io/issue-13-4/)
[Mantle/Mantle](https://github.com/mantle/mantle)

