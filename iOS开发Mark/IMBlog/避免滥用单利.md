#读 ObjC China 避免滥用单例

值得注意的概念。 

隐藏依赖、  比如一个方法里面的具体实现，它是由此类内部一些属性状态来决定。  但是开发者在使用这个类的时候，可能一下子并不完全了解此类里面 所声明的各个 属性等等 。 
这种隐藏依赖的关系，就很容易导致 开发出来的 接口，让其他开发者使用起来并不是很理想。  因为每次还要去看实现，然后发现实现里面的属性 关系等等。
我们在写接口的时候 应该尽量去避免 隐藏依赖 

文章列子一、


[] 避免单利使两个完全 分离的类 产生隐藏的耦合度
 由于其具有全局和多状态的特性，导致隐式地在两个看起来完全不相关的模块之间建立了耦合。


[] 单例的声明周期、单例的设计模式中就有说明， 其声明周期应该是从 创建开始 直到应用程序声明周期结束，才一起被释放掉的， 但是这只是定义， 在Code 中并没有明确的要求，不能手动销毁掉单例，然后重新去创建。
也是因为这样作者举了一个 单例在开发中 被滥用，没有根据单例初衷的设计模式 编程， 为了迎合 后面的业务需求 去改变 单例的设计模式， 手动去销毁掉单例，最终 也导致后面出现的 一些问题。
开发者 尝试 使用 单例来管理 当前用户的 图片， 但是用户在注销应用时 ，相对业务逻辑来说，此单例也应用要注销掉， 否则别的账号，也会读取到这份数据，明显是不对的 。  所以开发者 采用的手动 结束单例 生命周期的方法， 但是假如此单例被结束生命周期前 ， 还在后台异步执行 下载任务。  销毁掉之后，等下载完成，又重新生成了单例，并保存到了 另一个账号上，  这明显是不应该方法的 。也不是我们想要的 ， 而且为了迎合此业务逻辑 开发者 还得抛弃 确保 单例 安全唯一访问的方法 dispatch_once 


这也是其中一种滥用单例模式的例子！！！
这里我们得到的教训是，单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。

[] 依赖注入，我们可以显式地把经过认证的 user 对象作为参数传递给这个 view controller。 这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入
总结、
1、尽量避免全局状态。 全局状态容易导致 后续代码 会受到部分代码的影响，  因为有些方法内部实现有状态决定， 但是由于单例的全局性，可能会被全局访问 修改了其状态最终导致 其难以测试，寻找问题。 
2、尽量避免隐藏依赖。  由于单例具有全局访问性，  所以在应用程序中，可能会有多个类在访问此单例，  此单例的方法内部可能会有不同的属性， 方法实现也可能会依赖于属性， 这就导致了 很多不相关的类由于这个原因就导致成了 隐藏的依赖关系。 要尽量避免！！！！！  
3、使用单例应该尽量遵守 其原有设计模式 初衷，全局性，唯一，生命周期随应用程序自动结束。  可能我们在使用单例过程中，由于前期的业务逻辑较为简单，或许其还稍微符合当前业务，所以选择使用单例来进行管理， 但是可能后面业务逻辑的修改等， 导致我们可能会违背了 单例 设计模式的初衷 ， 如在应用程序周期还未结束 就手动 对单例进行销毁， 又重新创建等等， 这里也可能会出现一些意想不到的问题 。  
 解决这个问题的方法有 采用 依赖 注入的方式来进行管理。 
 显示的依赖注入方式。


## 隐藏依赖

隐私依赖是由于某些类, 我们在定义其 Api 时导致的, 举个例子比如我们项目中有一个计算 相加或者 相减的类, 这个类的方法公开出来的时候, 并没有有将两个进行相加或相减的参数公开到 方法 参数上, 而是通过变量声明的形式来进行,  这样有时候我们在调用的时候, 并不能很明显的看到这两个实际做运算的参数, 我们还需要跳转到类的内部里面才得知这两个数的由来。

这种模式严重影响的开发效率, 开发者不能很快的得知实现信息。
并且明显有严重的耦合性。
我们应该尽量把参数公开声明出来使用。

## 声明周期

单例定义出来的时候, 其就是一个全局的实例, 由自己管理自己的生命周期, 不需要人为去进行销毁, 它随着应用程序的销毁而自动销毁掉。 

但是在开发过程中, 我们很容易踩到这个由于单利的声明周期问题导致的问题, 有可能是后台产品需求变动导致, 也有可能是开发前没有深度思考导致, 举个例子:
1. 客户端里面有一个保存用户缓存的图片, 信息等实例类, 这时候可能我们为了让其全局可访问, 方便读取与修改, 将其设计成了单例,  但是后面产品增加了一个注销功能, 很明显注销的时候, 个人用户信息随着更换账号也需要更换了, 这时候我们可能为了临时顺应产品变更, 将这个单例在注销的时候进行了销毁, 这样虽然逻辑成能走得通, 但是我们也只能抛弃掉了系统提供的 dispatch_once 代码段,保证应用程序只执行一次的线程方法。  并且也违背的单例定义的原理。
2. 上面说的可能还比较好解决, 在深入思考一下, 加入上面说的这个单例类, 有一个异步下载用户信息的方法, 那么这时候就更加异常麻烦了,  我们在注销的同时必须保证单例的下载方法也要关闭停止掉, 否则将会影响到下一个用户, 这种时候我们在使用单例的时候必须三思而后行。
3. 遵守单例的设计模式初衷: 全局性，唯一，生命周期随应用程序自动结束。 

## 参考

[instance](https://www.objccn.io/issue-13-2/)


