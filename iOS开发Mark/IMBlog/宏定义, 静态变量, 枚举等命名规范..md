# 常用关键字 static、const、 extern、define 

[toc]

## const

常量: 共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段会执行类型检查.

- 全局常量
  
  包括在 .h .m 文件除非 **@implementation** 作用域内声明的, 都属于全局常量, 都可能由外部进行访问。
  外部文件访问时需要 使用关键字  **extern** 并且指明常量声明的类型来使用,  否则编译器默认以 int 类型来处理。应该是与运行时有关。
  参考:[iOS 宏(define)与常量(const)的正确使用](https://www.jianshu.com/p/f83335e036b5)
  
- 局部常量
  在 .m **@implementation** 内 方法实现内进行声明, 只作用于

主要用于修饰 C 或 OC 数据类型, 使声明的变量定义为常量。

三种修饰写法不同作用.

- const NSString * name = @"Jersey";
使 *name 指针地址不可变, 实际指向内容不受影响, 修改指针地址编译器报错。
- NSString const * name = @"Jersey";
同上面写法一致.
- NSString * const name = @"Jersey";
使 *name 指针指向内容不可变, 指针地址不受影响, 修改内容则编译报错。

**总结:**  const 修饰其后面内容。

## static

主要用于修饰变量或常量, 使其成为静态变量或常量,延长其生命周期, 可用于修饰局部变量和全局变量。 使用其来修饰的数据类型使其变为静态类型。 

- 静态类型

1. 在全局变量前加static，全局变量就被定义成为一个全局静态变量（全局变量和静态全局变量的生命周期是一样的，都是在堆中的静态区，在整个工程执行期间内一直存在） 特点如下：
 1）存储区：静态存储区没变（静态存储区在整个程序运行期间都存在);
 2）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。非静态全局 变量的作用域是整个源程序（多个源文件可以共同使用);

而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。
好处：   
> 不会被其他文件所访问，修改；
> 其他文件中可以使用相同名字的变量，不会发生冲突。

作者：Peak_One
链接：https://www.jianshu.com/p/3fa703e80720
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。


- 修饰局部变量

1. 延长局部变量的生命周期,程序结束才会销毁。
2. 局部变量只会生成一份内存,只会初始化一次。
3. 虽然出了声明的作用域,并且其未销毁,但是并无法进行访问。  
4. 存储区域由 栈 转移到 静态存储区。

- 修饰全局变量

1. 改变其作用域,只能在当前文件下访问,其他文件不可见。
2. 其他文件如果声明同名则不会报错,也不会对此全局变量有影响。

- 修饰函数

类似修饰变量的作用。


## extern

**主要有三种用法:**

- 使用其来声明供外部使用。(这里为什么还需要特意使用其来添加声明, 必须要引用 .h 才可以使用,  因为在 .h @interface @end 作用域内或者外, 声明都会编译报错, 系统默认其为 全局的, 所以我们必须还要使用 extern 关键字修饰)
- 使用其来声明引用外部变量等。

一般使用都是搭配  const 来使用.
在 .h 文件 使用 extern 修饰如:
extern const NSString * name;
.m 实现
const NSString * name = @"jersey";

实现必须遵守声明格式。 类型 + 变量名;
extern NSString* const name;
NSString* const name = @"jersey";
extern const NSString* name;
NSString* name = @"jersey";  // 不知道为什么这种格式没报错. 

## define

- 简介:

只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，"Hello world" 与 "world" 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大。

作者：汉斯哈哈哈
链接：https://www.jianshu.com/p/f83335e036b5
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

- define 与 const 区别:

宏定义是在预编译期间处理, 在使用时系统直接进行的方法替换, 静态变量等则是在编译期间进行的。
苹果推荐我们在开发中尽量使用常量。 
宏定义不会系统不会做编译检查, 所以类型错误也能通过编译, const 则会做编译检查。
能显式的声明数据类型, 并且不会出现自己定义的宏被其他人员更换,导致出现难以排查的 Bug。
不过宏不仅能对数据类型进行定义, 还能对 函数, 结构体, 方法等进行定义 相对比起常量来说作用会更多一些。

在实际开发中, 对于能使用常量定义完成的, 尽量使用常量能实现, 而不要考虑使用 宏。



参考: [OC中关键字extern、static、const探究](https://www.jianshu.com/p/3fa703e80720)
[【如何正确使用const,static,extern】|那些人追的干货](https://www.jianshu.com/p/2fd58ed2cf55)
[iOS 宏(define)与常量(const)的正确使用](https://www.jianshu.com/p/f83335e036b5)


