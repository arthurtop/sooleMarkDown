# UI图像显示原理  

## 概要

 CPU 与 GPU 通过连接总线将结果进行输出, CPU 一般输出 bitmip 到 GPU, 经由总线在合适的时机传输到 GPU, GPU 主要工作是进行图层的渲染, 纹理的合成, 这些参数都是通过  bitmip 获取, 得到的结果在存储到 Frame Buffer 桢缓存区内。 帧缓冲区将结果指定输出到视频控制器上。
 
## V-Snyc

在最简单的情况下, 桢缓存区只有一个, 工作原理基本是屏幕显示器等待着 GPU 将结果提交到缓存区, 然后到合适的时机输出到视频显示器上进行显示, 但是这样效率明显是不够优的, 从而引入双缓存机制来解决效率为。

为了提高桢缓存区的读取和刷新的效率,  引入了一种双缓存机制来提交效率, 单引入双缓存机制在 GPU 处理不当的情况下, 会引起画画撕裂的现象。 主要是由于 GPU 这边不能确定缓存区是否已经显示完这一桢画面,  然后他会自动去进行渲染, 更新缓存区内容。 导致双缓存区直接显示时造成错误。

为了解决画画撕裂的现象, GPU 引入了 垂直同步 V-Snys, 当开启垂直同步之后, GPU 会等待显示器的 VSync 信号发出后, 才进行新的一桢的渲染和缓冲区更新, 这样既可解决画面撕裂, 也增加了画面流畅度, 单需要消费更多的计算资源, 也会带来部分延迟。
那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步

## 卡顿原因

![](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png)

由于采用了  V-Sync 机制, 在信号到来后, 系统图形服务会通过  CADisplayLink 等机制通知到 App, App 主线程开始在 CPU 进行 创建,文本计算,布局,绘制,图片编码等, 随后通过 Core Animation 提交到 GPU(OPEN GL), GPU 拿到 Bitmip 对其进行变换, 渲染, 纹理合成, 顶点着色, 光栅化, 完成之后 GPU 将其提交到 Frame Buffer, 继续等待下一个信号的到来。

帧缓冲区在合适的时机将其输出到视频控制器上进行显示。

一般人的视觉对于 60FPS 是相对最流畅的体验, 如果低于或者高于会很容易视觉感受出来, 比如 60FPS 那么 1桢 相对于 0.16 ms, 那么 CPU + GPU 必须要在收到信号之后, 0.16 ms 内完成最终图像的合成, 并且提交到缓冲区内, 否则错过时间之后, 视频控制器会直接放弃掉这一桢, 画面就保持在了 上一桢, 继而等待下一桢的显示时机到来在重新发出信号, 最后显示, 从而一个画面会停留 2 桢, 这样一样就会让人产生了一种卡顿的感觉。 

## 例子:
以一个 UIView 显示到屏幕为例子。

CALayer(drawRect:) -> contents -> Hello world -> Core Animation 提交 CPU -> GPU OpenGL(ES) -> Screen

## CPU

主要工作:
* Layout: UI布局, 文本计算
* Display: 绘制 drawRect:
* Prepare: 图片编解码
* Commit: 提交位图 

## GPU

主要工作:

* 顶点着色:
* 图元装配:
* 光栅化:
* 片段着色:
* 片段处理:

最终将其提交到 FrameBuffer。

## 参考

[保持屏幕流畅性](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#2)

