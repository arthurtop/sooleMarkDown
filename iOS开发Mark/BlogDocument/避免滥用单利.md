#读 ObjC China 避免滥用单例

值得注意的概念。 

隐藏依赖、  比如一个方法里面的具体实现，它是由此类内部一些属性状态来决定。  但是开发者在使用这个类的时候，可能一下子并不完全了解此类里面 所声明的各个 属性等等 。 
这种隐藏依赖的关系，就很容易导致 开发出来的 接口，让其他开发者使用起来并不是很理想。  因为每次还要去看实现，然后发现实现里面的属性 关系等等。
我们在写接口的时候 应该尽量去避免 隐藏依赖 

文章列子一、


[] 避免单利使两个完全 分离的类 产生隐藏的耦合度
 由于其具有全局和多状态的特性，导致隐式地在两个看起来完全不相关的模块之间建立了耦合。


[] 单例的声明周期、单例的设计模式中就有说明， 其声明周期应该是从 创建开始 直到应用程序声明周期结束，才一起被释放掉的， 但是这只是定义， 在Code 中并没有明确的要求，不能手动销毁掉单例，然后重新去创建。
也是因为这样作者举了一个 单例在开发中 被滥用，没有根据单例初衷的设计模式 编程， 为了迎合 后面的业务需求 去改变 单例的设计模式， 手动去销毁掉单例，最终 也导致后面出现的 一些问题。
开发者 尝试 使用 单例来管理 当前用户的 图片， 但是用户在注销应用时 ，相对业务逻辑来说，此单例也应用要注销掉， 否则别的账号，也会读取到这份数据，明显是不对的 。  所以开发者 采用的手动 结束单例 生命周期的方法， 但是假如此单例被结束生命周期前 ， 还在后台异步执行 下载任务。  销毁掉之后，等下载完成，又重新生成了单例，并保存到了 另一个账号上，  这明显是不应该方法的 。也不是我们想要的 ， 而且为了迎合此业务逻辑 开发者 还得抛弃 确保 单例 安全唯一访问的方法 dispatch_once 


这也是其中一种滥用单例模式的例子！！！
这里我们得到的教训是，单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。

[] 依赖注入，我们可以显式地把经过认证的 user 对象作为参数传递给这个 view controller。 这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入
总结、
1、尽量避免全局状态。 全局状态容易导致 后续代码 会受到部分代码的影响，  因为有些方法内部实现有状态决定， 但是由于单例的全局性，可能会被全局访问 修改了其状态最终导致 其难以测试，寻找问题。 
2、尽量避免隐藏依赖。  由于单例具有全局访问性，  所以在应用程序中，可能会有多个类在访问此单例，  此单例的方法内部可能会有不同的属性， 方法实现也可能会依赖于属性， 这就导致了 很多不相关的类由于这个原因就导致成了 隐藏的依赖关系。 要尽量避免！！！！！  
3、使用单例应该尽量遵守 其原有设计模式 初衷，全局性，唯一，生命周期随应用程序自动结束。  可能我们在使用单例过程中，由于前期的业务逻辑较为简单，或许其还稍微符合当前业务，所以选择使用单例来进行管理， 但是可能后面业务逻辑的修改等， 导致我们可能会违背了 单例 设计模式的初衷 ， 如在应用程序周期还未结束 就手动 对单例进行销毁， 又重新创建等等， 这里也可能会出现一些意想不到的问题 。  
 解决这个问题的方法有 采用 依赖 注入的方式来进行管理。 
 显示的依赖注入方式。


## 参考

[instance](https://www.objccn.io/issue-13-2/)


