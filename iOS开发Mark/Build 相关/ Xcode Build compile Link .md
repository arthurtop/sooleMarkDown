#  Xcode Build compile Link 

## 简介
在开发过程中, 可能我们经常碰到的一个问题是, 不同的项目, 不同的体积导致不同的项目出现编译时间的不同, 有时候因为每次编译时间过长, 让正好找到 Code inspiration 的你头疼不已, 所以我认为提高项目的编译时间对我们来说是非常有必要的, 想要解决一个问题, 我们必须要清楚整个编译实现的过程, 进而在去优化, 做到对症下药才能解决问题本质。

## LLVM  LLD

LLVM 是目前 Apple 正在使用的编译器, 相比 Xcode 5 之前使用的 GCC, 编译速度提高了 3 倍。 同时在 Swift 之父的引领下 Apple 反过来主导了 LLVM 的发展, 让 LLVM 可以针对 Apple 的硬件进行更多的优化。

总的来说,  LLVM 是编译器工具技术的一个集合, 它还包含 LLD 项目, 就是内置的链接器。

* 编译的几个主要过程: 
1. 首先，你写好代码后，LLVM 会预处理你的代码，比如把宏嵌入对应的位置。
2. 预处理完成后, LLVM 会对代码进行词法分析和语法分析, 进而生成 AST (机器可直接理解的Code). 
3. 最后通过相应的工具, 将 AST 生成 IR。

* 编译链接
1. 编译器会对每个文件进行编译, 生成对应的 "Mach-O(可执行文件)" ;
2. 链接器会将编译生成的多个 Mach-O 进行合并成一个, 并且对其进行绑定地址。

## 链接器

Mach-O 文件里面的内容，主要就是代码和数据：代码是函数的定义; 数据是全局变量的定义, 包括全局变量的初始值. 不管是代码还是数据, 它们的实例都需要由符号将其关联起来。

通过上面的概括, 我们了解到通过  LLVM 编译源码, 使每个对应的文件生成 Mach-O, 并且也将其代码编译成了 AST IR, 让机器可以直接的去执行, 但是为什么还需要有链接这一个步骤呢, 因为虽然 Mach-O 里面的代码 机器可以完全读懂,  但是里面所声明的 函数, 变量, 全局变量 等等数据, 都是需要存储到程序的内存空间去的, 这样机器就可以直接通过内存地址去查找到相应的代码, 所以必须要将变量符号绑定到数据对应的存储空间上去。

链接器的作用: 完成变量, 函数符号和其他地址绑定的任务。 

链接器在链接多个目标文件的过程中, 会创建一个符号表,用于记录所有已定义和所有未定义的符号。链接时如果出现相同符号的情况, 就会出现 "id: dumplicate symbols" 的错误信息; 如果在其他目标文件里没有找到符号, 就会提示 "Undefined symbols" 错误信息.

* 链接器对代码做了那几件事
1. 去项目文件里查找目标代码文件里没有定义的变量。
2. 扫描项目中的不同文件, 将所有符号定义和引用地址收集起来, 并放到全局符号表中。
3. 计算并合并长度及位置, 生成同类型的段进行合并, 建立绑定。
4. 对项目中不同文件里的变量进行地址重定位。

链接器在整理函数的调用关系时, 会以 Main 函数为源头, 跟随每个引用, 并将其标记为 live. 跟随完成后, 那些未被标记为 live 的函数, 就是无用函数。 然后, 链接器可以通过打开 Dead code Stripping 开关, 来开启自动取出无用代码的功能。 Xcode 默认开启. 

## AST

AST 是抽象语法树, 结构上比代码更为简洁, 遍历起来更快, 所有使用 AST 能够更快速地进行静态检查, 同时还能快速地生成 IR.
一般在编译期间 LLVM 会将源码编译成 AST.

# IR

其与 AST 的区别在于其可以独立的运行在某个操作系统时, 比如针对 arm 64.bin x86-64.bin 等操作系统上, 所以在针对每个操作系统还需要将 AST 编译生成成对应 操作系统的 IR 代码, 其是一种更为简洁 接近计算机语言的语言。


## 动态库链接

链接的公用库分为静态库和动态库: 静态库是编译时链接的库, 需要链接进你的 Mach-O 文件里, 如果需要更新就要重新编译一次, 无法动态加载和更新; 而动态库是运行时链接的库, 使用 dyly 就可以实现动态绑定。

一般在编译生成 mach-O 文件时, 会将相应的静态库一起打包进来, 所以也很容易导致系统的体积过大。 

Mach-O 文件是编译后的产物，而动态库在运行时才会被链接, 并没有参加 Mach-O 文件的编译和链接, 所以 Mach-O 文件中并没有包含动态库里的符号定义。所以动态库里面的符号会显示未 "未定义", 但它们的名字和对应的路径会被记录下来。 运行时通过 dlopen 和 dlsym 导入动态库时, 先根据记录的库路径找到对应的库, 在通过记录的名字符号找到绑定的地址。

* 使用 dyld 加载动态库有两种方式: 
1. 程序启动加载时进行绑定。
2. 符号第一次被用到时绑定。
为了减少启动时间通常都会采用第二种方式, 类似懒加载。

## 模拟, 编译链接

1.  xcrun clang -c Boy.m
xcrun clang -c SayHi.m 编译等到 Mach-O 文件 
2.  xcrun clang SayHi.o Boy.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation   将两个 .o 文件进行链接。生成 a.out 可执行文件。
3. xcrun nm -nm SayHi.o  借助 nm 工具可以查看链接直接的 可执行文件代码.

我们可以看到 文件内使用的 类, 函数, 变量等 都会修改成符号的形式, 然后前缀都是以 内存地址开头或者 (undefined) , 实际上确认的内存地址可能是从静态库引用。 

因为 undefined 符号表示该文件类未定义, 所以在目标文件和 Fundation framework 动态库做链接处理时, 链接器会尝试解析所有 undefined 符号。

## dyld

通过查看 a.out 文件, 可以查看到动态链接的库路径, 也会看到不少的 .dylib 格式的文件, 其表示动态链接, 编译的时候不会被编译到执行文件中, 在程序执行的时候才 Link.

* dyld 做了几件事

1. 





## 参考


[05 | 链接器：符号是怎么绑定到地址上的？](https://time.geekbang.org/column/article/86840)
[完整编译过程官方文档](http://llvm.org/docs/)


